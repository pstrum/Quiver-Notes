{
  "title": "Running Time of Algorithms",
  "cells": [
    {
      "type": "text",
      "data": "<h2 id=\"running-time-of-algorithms\">Running Time of Algorithms</h2>\n<p>The running time of an algorithm for a specific input depends on the number of operations executed. The greater the number of operations, the longer the running time of an algorithm. We usually want to know how many operations an algorithm will execute in proportion to the size of its input, which we will call N.</p>\n<p><strong>For example</strong>, the first two input files for Insertion Sort were small, so it was able to sort them quickly. But the next two files were larger and sorting them took more time. What is the ratio of the running time of Insertion Sort to the size of the input? To answer this question, we need to examine the Insertion Sort algorithm.</p>\n<h2 id=\"analysis-of-insertion-sort\">Analysis of Insertion Sort</h2>\n<p>For each element V in an array of N numbers, Insertion Sort shifts everything to the right until it can insert V into the array.</p>\n<h2 id=\"how-long-does-all-that-shifting-take-\">How long does all that shifting take?</h2>\n<p>In the best case, where the array was already sorted, no element will need to be moved, so the algorithm will just run through the array once and return the sorted array. The running time would be directly proportional to the size of the input, so we can say it will take N time.</p>\n<p>However, we usually focus on the worst-case running time (computer scientists are pretty pessimistic). The worst case for Insertion Sort occurs when the array is in reverse order. To insert each number, the algorithm will have to shift over that number to the beginning of the array. Sorting the entire array of N numbers will therefore take 1+2+...+(N−1) operations, which is N(N−1)/2 (almost N2/2). Computer scientists just round that up (pick the dominant term) to N2 and say that Insertion Sort is an \"N2 time\" algorithm.</p><p><img src=\"quiver-image-url/AF34E476B04DABC6C4F930BE481EEE65.jpg\"><br></p>\n<h2 id=\"what-this-means\">What this means</h2>\n<p>As the size of an input (N) increases, Insertion Sort's running time will increase by the square of N. So Insertion Sort can work well for small inputs, but becomes unreasonably slow for larger inputs. For large inputs, people use sorting algorithms that have better running times, which we will examine later.</p>\n<h2 id=\"challenge\">Challenge</h2>\n<p>Can you modify your previous Insertion Sort implementation to keep track of the number of shifts it makes while sorting? The only thing you should print is the number of shifts made by the algorithm to completely sort the array. A shift occurs when an element's position changes in the array. Do not shift an element if it is not necessary.</p>\n<h2 id=\"input-format\">Input Format</h2>\n<p>The first line contains N, the number of elements to be sorted. The next line contains N integers a[1], a[2], ..., a[N].</p>\n<h2 id=\"output-format\">Output Format</h2>\n<p>Output the number of shifts it takes to sort the array.</p>\n<h2 id=\"constraints\">Constraints</h2>\n<p>1≤N≤1001<br>−10000≤x≤10000,x∈a</p>\n<h2 id=\"sample-input\">Sample Input</h2>\n<p>5<br>2 1 3 1 2</p>\n<h2 id=\"sample-output\">Sample Output</h2>\n<p>4</p>\n<h2 id=\"explanation\">Explanation</h2>\n<p>The first 1 is shifted once. The 3 stays where it is. The next 1 gets shifted twice. The final 2 gets shifted once. Hence, the total number of shifts is 4.</p>\n<h2 id=\"task\">Task</h2>\n<p>For this problem, you can copy your code from the InsertionSort problem, and modify it to keep track of the number of shifts instead of printing the array.</p>\n"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "function processData(input) {\n  \"use strict\";\n  \n  var counter = 0;\n  var arr = input.split(/\\n| /);\n  arr.splice(0, 1);\n  \n  for (let i = 0; i < arr.length - 1; i++) {\n    \n    var currentValue = Number(arr[i]);\n    var nextValue = Number(arr[i + 1]);\n    var currentIndex = i;\n    \n    if (currentValue > nextValue) {\n      arr[i + 1] = currentValue;\n      if (currentIndex === 0) {\n        arr[i] = nextValue;\n      }\n      while (currentIndex >= 0) {\n        var prevValue = Number(arr[currentIndex - 1]);\n        if (nextValue < prevValue) {\n          arr[currentIndex] = arr[currentIndex - 1];\n          counter++;\n        } else {\n          arr[currentIndex] = nextValue;\n          counter++;\n          break;\n        }\n        currentIndex--;\n      }\n    }\n  }\n  console.log(counter);\n}"
    }
  ]
}